# -*- coding: utf-8 -*-
"""two_channel_results.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qj8jQPYGoi6ArFOiM8c2kepaOUhWPRye
"""

from google.colab import drive

drive.mount('/content/drive', timeout_ms=60000)

!pip install pyedflib



import pyedflib
import numpy as np
import matplotlib.pyplot as plt

# Define the path to your original EDF file
edf_file = '/content/drive/MyDrive/sleep-edf-database-expanded-1.0.0/sleep-edf-database-expanded-1.0.0/sleep-cassette/SC4021E0-PSG.edf'

# Open the original EDF file for reading
edf_reader = pyedflib.EdfReader(edf_file)

# Get the list of channel labels
channel_labels = edf_reader.getSignalLabels()

# Keep the first two channels and remove the rest
channels_to_keep = channel_labels[:2]

# Create a new EDF file for writing (temp file)
temp_edf_file = '/content/drive/MyDrive/temp2.edf'
edf_writer = pyedflib.EdfWriter(temp_edf_file, len(channels_to_keep))

# Copy the header information to the new EDF file
edf_writer.setHeader(edf_reader.getHeader())

# Find the indices of channels to keep
channel_indices = [channel_labels.index(channel) for channel in channels_to_keep]

# Create an array to store the data for the first two channels
first_two_channel_data = []

# Iterate through channels, but only copy data for the first two channels
for i, channel_index in enumerate(channel_indices):
    samples = edf_reader.readSignal(channel_index)
    edf_writer.writePhysicalSamples(samples)

    # If it's one of the first two channels, store the data
    if i < 2:
        first_two_channel_data.append(samples)

# Close both the reader and the writer
edf_reader.close()
edf_writer.close()

# Print the channel labels
print("Original Channels:", channel_labels)
print("Channels to Keep:", channels_to_keep)

# Plot the data for the first two channels
time = np.arange(0, len(first_two_channel_data[0])) / edf_reader.getSampleFrequency(channel_indices[0])
plt.figure(figsize=(12, 6))
plt.subplot(2, 1, 1)
plt.plot(time, first_two_channel_data[0])
plt.title(f"Channel 1: {channels_to_keep[0]}")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.subplot(2, 1, 2)
plt.plot(time, first_two_channel_data[1])
plt.title(f"Channel 2: {channels_to_keep[1]}")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.tight_layout()
plt.show()

import pyedflib
import numpy as np
import matplotlib.pyplot as plt

# Define the path to the temporary EDF file
temp_edf_file = '/content/drive/MyDrive/temp2.edf'

# Open the temporary EDF file for reading
edf_reader = pyedflib.EdfReader(temp_edf_file)

# Get the list of channel labels
channel_labels = edf_reader.getSignalLabels()

# Create an array to store the data for all channels
channel_data = []

# Read and store the data for each channel
for i in range(len(channel_labels)):
    samples = edf_reader.readSignal(i)
    channel_data.append(samples)

# Close the EDF reader
edf_reader.close()

# Print the channel labels
print("Channels in the Temporary EDF File:", channel_labels)

# Plot the data for each channel
time = np.arange(0, len(channel_data[0])) / edf_reader.getSampleFrequency(0)
plt.figure(figsize=(12, 6))
for i in range(len(channel_labels)):
    plt.subplot(len(channel_labels), 1, i + 1)
    plt.plot(time, channel_data[i])
    plt.title(f"Channel {i + 1}: {channel_labels[i]}")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
plt.tight_layout()
plt.show()

!pip install scipy

import pyedflib
import numpy as np
from scipy.signal import butter, lfilter
import matplotlib.pyplot as plt

# Define the path to the temporary EDF file
temp_edf_file = '/content/drive/MyDrive/temp2.edf'

# Function to apply a bandpass filter to the data
def apply_bandpass_filter(data, lowcut, highcut, fs, order=4):
    nyquist = 0.8 * fs
    low = lowcut / nyquist
    high = highcut / nyquist
    b, a = butter(order, [low, high], btype='band')
    filtered_data = lfilter(b, a, data)
    return filtered_data

# Define the sub-bands
subbands = {
    "Delta (0.5–4 Hz)": (0.5, 4),
    "Theta (4–8 Hz)": (4, 8),
    "Alpha (8–12 Hz)": (8, 12),
    "Sigma (12–16 Hz)": (12, 16),
    "Beta (16–40 Hz)": (16, 40),
}

# Open the temporary EDF file for reading
edf_reader = pyedflib.EdfReader(temp_edf_file)

# Get the list of channel labels
channel_labels = edf_reader.getSignalLabels()

# Create an array to store the data for all channels
channel_data = []

# Read and store the data for each channel
for i in range(len(channel_labels)):
    samples = edf_reader.readSignal(i)
    channel_data.append(samples)

# Close the EDF reader
edf_reader.close()

# Sample frequency
fs = edf_reader.getSampleFrequency(0)

# Time vector
time = np.arange(0, len(channel_data[0])) / fs

# Apply bandpass filters and plot sub-bands
plt.figure(figsize=(12, 10))
for i, (subband_name, (lowcut, highcut)) in enumerate(subbands.items()):
    plt.subplot(len(subbands), 1, i + 1)
    plt.title(f"{subband_name} Band")

    for channel_index, channel_label in enumerate(channel_labels):
        # Apply the bandpass filter to the data
        filtered_data = apply_bandpass_filter(channel_data[channel_index], lowcut, highcut, fs)

        # Plot the filtered data
        plt.plot(time, filtered_data, label=f"Channel {channel_label}")

    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
    plt.legend()

plt.tight_layout()
plt.show()

import pyedflib
import numpy as np
from scipy.signal import butter, lfilter
import matplotlib.pyplot as plt

# Define the path to the temporary EDF file
temp_edf_file = '/content/drive/MyDrive/temp2.edf'

# Function to apply a bandpass filter to the data
def apply_bandpass_filter(data, lowcut, highcut, fs, order=4):
    nyquist = 0.8 * fs
    low = lowcut / nyquist
    high = highcut / nyquist
    b, a = butter(order, [low, high], btype='band')
    filtered_data = lfilter(b, a, data)
    return filtered_data

# Define the sub-bands
subbands = {
    "Delta (0.5–4 Hz)": (0.5, 4),
    "Theta (4–8 Hz)": (4, 8),
    "Alpha (8–12 Hz)": (8, 12),
    "Beta (16–40 Hz)": (16, 40),
    "Gamma (40–70 Hz)": (40, 70)
}

# Open the temporary EDF file for reading
edf_reader = pyedflib.EdfReader(temp_edf_file)

# Get the list of channel labels
channel_labels = edf_reader.getSignalLabels()

# Create an array to store the data for all channels
channel_data = []

# Read and store the data for each channel
for i in range(len(channel_labels)):
    samples = edf_reader.readSignal(i)
    channel_data.append(samples)

# Close the EDF reader
edf_reader.close()

# Sample frequency
fs = edf_reader.getSampleFrequency(0)

# Calculate the FFT for each sub-band for each channel
fft_results = {}
for subband_name, (lowcut, highcut) in subbands.items():
    fft_results[subband_name] = []
    for channel_index, channel_label in enumerate(channel_labels):
        # Apply the bandpass filter to the data
        filtered_data = apply_bandpass_filter(channel_data[channel_index], lowcut, highcut, fs)

        # Calculate the FFT of the filtered data
        fft_data = np.abs(np.fft.fft(filtered_data))

        # Store the FFT data
        fft_results[subband_name].append(fft_data)

# Display the FFT results
for subband_name, fft_values in fft_results.items():
    print(subband_name)
    for i, channel_label in enumerate(channel_labels):
        mean_fft = np.mean(fft_values[i])
        print(f"Channel {channel_label}: {mean_fft:.2f}")

# Plot the FFT values
plt.figure(figsize=(12, 8))
for subband_name, fft_values in fft_results.items():
    plt.subplot(len(subbands), 1, list(subbands.keys()).index(subband_name) + 1)
    plt.title(subband_name)

    for i, channel_label in enumerate(channel_labels):
        plt.plot(fft_values[i], label=f"Channel {channel_label}")

    plt.xlabel("Frequency (Hz)")
    plt.ylabel("FFT Magnitude")
    plt.legend()

plt.tight_layout()
plt.show()

import pyedflib
import numpy as np
from scipy.signal import butter, lfilter
import scipy.stats

# Define the path to the temporary EDF file
temp_edf_file = '/content/drive/MyDrive/temp2.edf'

# Function to apply a bandpass filter to the data
def apply_bandpass_filter(data, lowcut, highcut, fs, order=4):
    nyquist = 0.8 * fs
    low = lowcut / nyquist
    high = highcut / nyquist
    b, a = butter(order, [low, high], btype='band')
    filtered_data = lfilter(b, a, data)
    return filtered_data

# Define the sub-bands
subbands = {
    "Delta (0.5–4 Hz)": (0.5, 4),
    "Theta (4–8 Hz)": (4, 8),
    "Alpha (8–12 Hz)": (8, 12),
    "Beta (16–40 Hz)": (16, 40),
    "Gamma (40–70 Hz)": (40, 70)
}

# Open the temporary EDF file for reading
edf_reader = pyedflib.EdfReader(temp_edf_file)

# Get the list of channel labels
channel_labels = edf_reader.getSignalLabels()

# Create an array to store the data for all channels
channel_data = []

# Read and store the data for each channel
for i in range(len(channel_labels)):
    samples = edf_reader.readSignal(i)
    channel_data.append(samples)

# Close the EDF reader
edf_reader.close()

# Sample frequency
fs = edf_reader.getSampleFrequency(0)

# Initialize a dictionary to store features
feature_results = {}

# Calculate and extract features from the sub-bands for each channel
for subband_name, (lowcut, highcut) in subbands.items():
    feature_results[subband_name] = {}
    for channel_index, channel_label in enumerate(channel_labels):
        # Apply the bandpass filter to the data
        filtered_data = apply_bandpass_filter(channel_data[channel_index], lowcut, highcut, fs)

        # Calculate and store features
        mean = np.mean(filtered_data)
        variance = np.var(filtered_data)
        skewness = scipy.stats.skew(filtered_data)
        kurtosis = scipy.stats.kurtosis(filtered_data)

        feature_results[subband_name][channel_label] = {
            "Mean": mean,
            "Variance": variance,
            "Skewness": skewness,
            "Kurtosis": kurtosis
        }

# Print and/or use feature_results as needed
print("Extracted Features:")
for subband_name, subband_features in feature_results.items():
    print(subband_name)
    for channel_label, features in subband_features.items():
        print(f"Channel {channel_label}:")
        for feature_name, value in features.items():
            print(f"  {feature_name}: {value:.2f}")

import pyedflib
import numpy as np
from scipy.signal import butter, lfilter
import scipy.stats
import matplotlib.pyplot as plt

# Define the path to the temporary EDF file
temp_edf_file = '/content/drive/MyDrive/temp2.edf'

# Function to apply a bandpass filter to the data
def apply_bandpass_filter(data, lowcut, highcut, fs, order=4):
    nyquist = 0.8 * fs
    low = lowcut / nyquist
    high = highcut / nyquist
    b, a = butter(order, [low, high], btype='band')
    filtered_data = lfilter(b, a, data)
    return filtered_data

# Define the sub-bands
subbands = {
    "Delta (0.5–4 Hz)": (0.5, 4),
    "Theta (4–8 Hz)": (4, 8),
    "Alpha (8–12 Hz)": (8, 12),
    "Beta (16–40 Hz)": (16, 40),
    "Gamma (40–70 Hz)": (40, 70)
}

# Open the temporary EDF file for reading
edf_reader = pyedflib.EdfReader(temp_edf_file)

# Get the list of channel labels
channel_labels = edf_reader.getSignalLabels()

# Create an array to store the data for all channels
channel_data = []

# Read and store the data for each channel
for i in range(len(channel_labels)):
    samples = edf_reader.readSignal(i)
    channel_data.append(samples)

# Close the EDF reader
edf_reader.close()

# Sample frequency
fs = edf_reader.getSampleFrequency(0)

# Calculate the FFT for each sub-band for each channel
fft_results = {}
for subband_name, (lowcut, highcut) in subbands.items():
    fft_results[subband_name] = []
    for channel_index, channel_label in enumerate(channel_labels):
        # Apply the bandpass filter to the data
        filtered_data = apply_bandpass_filter(channel_data[channel_index], lowcut, highcut, fs)

        # Calculate the FFT of the filtered data
        fft_data = np.abs(np.fft.fft(filtered_data))

        # Store the FFT data
        fft_results[subband_name].append(fft_data)

# Select specific subbands (e.g., Alpha) and remove zero values
# Define the subbands you want to plot
subbands_to_plot = ["Alpha (8–12 Hz)", "Theta (4–8 Hz)", "Beta (16–40 Hz)"]

# Plot histograms of subband values (remove zero values) for the selected subbands
for subband_name_to_plot in subbands_to_plot:
    subband_data = np.array(fft_results[subband_name_to_plot])

    plt.figure(figsize=(12, 6))
    for i in range(len(channel_labels)):
        values = subband_data[i]
        non_zero_values = values[values > 0.0]  # Remove zero values
        plt.subplot(len(channel_labels), 1, i + 1)
        plt.hist(non_zero_values, bins=50, density=True)
        plt.title(f"Channel {channel_labels[i]} - {subband_name_to_plot}")
        plt.xlabel("FFT Magnitude")
        plt.ylabel("Density")

    plt.tight_layout()
    plt.show()


# Divide the EEG signals into epochs of 10 seconds
eeg_channel_1 = channel_data[0]
eeg_channel_2 = channel_data[1]

# Define the epoch duration in seconds
epoch_duration = 10  # 10 seconds

# Calculate the number of samples per epoch
samples_per_epoch = int(epoch_duration * fs)

# Calculate the total number of epochs
total_epochs = min(len(eeg_channel_1), len(eeg_channel_2)) // samples_per_epoch

# Create lists to store the epochs for each channel
eeg_epochs_channel_1 = []
eeg_epochs_channel_2 = []

# Divide the EEG signals into epochs
for epoch_index in range(total_epochs):
    start_sample = epoch_index * samples_per_epoch
    end_sample = (epoch_index + 1) * samples_per_epoch
    eeg_epochs_channel_1.append(eeg_channel_1[start_sample:end_sample])
    eeg_epochs_channel_2.append(eeg_channel_2[start_sample:end_sample])

time_axis = np.arange(0, epoch_duration, 1/fs)

# Plot the EEG epochs for each channel
for epoch_index in range(total_epochs):
    plt.figure(figsize=(12, 4))

    # Plot EEG data for channel 1
    plt.subplot(2, 1, 1)
    plt.plot(time_axis, eeg_epochs_channel_1[epoch_index])
    plt.title(f"EEG Epoch {epoch_index + 1} - Channel 1")
    plt.xlabel("Time (s)")
    plt.ylabel("EEG Amplitude")

    # Plot EEG data for channel 2
    plt.subplot(2, 1, 2)
    plt.plot(time_axis, eeg_epochs_channel_2[epoch_index])
    plt.title(f"EEG Epoch {epoch_index + 1} - Channel 2")
    plt.xlabel("Time (s)")
    plt.ylabel("EEG Amplitude")

    plt.tight_layout()
    plt.show()



import pyedflib
import numpy as np
import matplotlib.pyplot as plt

# Define the path to your original EDF file
edf_file =

# Open the original EDF file for reading
edf_reader = pyedflib.EdfReader(edf_file)

# Get the list of channel labels
channel_labels = edf_reader.getSignalLabels()

# Keep the first two channels and remove the rest
channels_to_keep = channel_labels[:2]

# Create a new EDF file for writing (temp file)
temp_edf_file = '/content/drive/MyDrive/temp2.edf'
edf_writer = pyedflib.EdfWriter(temp_edf_file, len(channels_to_keep))

# Copy the header information to the new EDF file
edf_writer.setHeader(edf_reader.getHeader())

# Find the indices of channels to keep
channel_indices = [channel_labels.index(channel) for channel in channels_to_keep]

# Create an array to store the data for the first two channels
first_two_channel_data = []

# Iterate through channels, but only copy data for the first two channels
for i, channel_index in enumerate(channel_indices):
    samples = edf_reader.readSignal(channel_index)
    edf_writer.writePhysicalSamples(samples)

    # If it's one of the first two channels, store the data
    if i < 2:
        first_two_channel_data.append(samples)

# Close both the reader and the writer
edf_reader.close()
edf_writer.close()

# Print the channel labels
print("Original Channels:", channel_labels)
print("Channels to Keep:", channels_to_keep)

# Plot the data for the first two channels
time = np.arange(0, len(first_two_channel_data[0])) / edf_reader.getSampleFrequency(channel_indices[0])
plt.figure(figsize=(12, 6))
plt.subplot(2, 1, 1)
plt.plot(time, first_two_channel_data[0])
plt.title(f"Channel 1: {channels_to_keep[0]}")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.subplot(2, 1, 2)
plt.plot(time, first_two_channel_data[1])
plt.title(f"Channel 2: {channels_to_keep[1]}")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.tight_layout()
plt.show()

from PIL import Image
import numpy as np
from skimage.feature import local_binary_pattern, hog
from skimage.color import rgb2gray
from skimage.filters import sobel

#Define a function to extract features from an image
def extract_features(image_path):
    # Load the image using Pillow
    image ='/content/drive/MyDrive/temp2.edf'

    # Resize the image to a consistent size (e.g., 224x224 pixels)
    image = image.resize((224, 224))

    # Convert the image to a NumPy array
    image = np.array(image)

    # Color features (mean, median, standard deviation)
    color_mean = np.mean(image, axis=(0, 1))
    color_median = np.median(image, axis=(0, 1))
    color_std = np.std(image, axis=(0, 1))

    # Convert the image to grayscale
    gray_image = rgb2gray(image)

    # Texture features (Local Binary Pattern)
    lbp_radius = 3
    lbp_n_points = 24
    lbp_features = local_binary_pattern(gray_image, lbp_n_points, lbp_radius, method='uniform')
    lbp_hist, _ = np.histogram(lbp_features.ravel(), bins=np.arange(0, lbp_n_points + 3), range=(0, lbp_n_points + 2))
    lbp_hist = lbp_hist / (lbp_hist.sum() + 1e-6)  # Normalize

    # Edge features (Canny)
    edges = canny(gray_image)
    num_edges = np.sum(edges)

    # Statistical features
    skewness = skew(gray_image.ravel())
    kurt = kurtosis(gray_image.ravel())

    # Concatenate all features
    all_features = np.concatenate([
        color_mean, color_median, color_std,
        lbp_hist,
        [num_edges],
        [skewness, kurt]
    ])

    return all_features

# Example usage:
image_path = r'E:\final_project\colon_lungs_dataset\colonca1.jpeg'
features = extract_features(image_path)

# Display the extracted features clearly with labels
feature_names = [
    'Color Mean (R, G, B)', 'Color Median (R, G, B)', 'Color Std Dev (R, G, B)',
    'LBP Histogram',
    'Number of Edges',
    'Skewness', 'Kurtosis'
]

for feature_name, feature_value in zip(feature_names, features):
    print(f"{feature_name}: {feature_value}")